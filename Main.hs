-- Name: Brandon Lim Vei Liang 
-- Student id : 1430381
-- Summary
-- This program attempts to predict the target set of cards by iteratively generating guesses, 
-- by eliminating the incorrect answers based on the feedback

-- Description of the file
-- This file consists of three main functions : initialGuess, feedback and nextGuess. Each of
-- these functions perform the main goal of the project - to predict a set of cards. This file
-- is structured in a way such that the 3 main functions are at the top, and the helper functions
-- for the corresponding functions are located after the 3 main functions, in the same order but
-- separated by a line of dashes (-) to improve readability. Many helper functions are created for
-- the main functions to hopefully improve the readability and the flow of the main functions, by 
-- making them less convoluted. 
module Proj2 (feedback, initialGuess, nextGuess, GameState) where

import Card
import Data.List 

-- declaring GameState to be of type list of list of Cards
type GameState = [[Card]]

-- takes in an int n which is the size of the target, and generates a [Card] guess of the same
-- size as well as creating the GameState which is a set of possible answers for all combinations
-- of cards of size n. The guess is generated by dividing 13 by the size of the target, the results
-- are then used to call toEnum iteratively depending on the size. The -2 in the argument for toEnum
-- is to ensure that the first card is not too centered, so that it can cover more range, and the
-- abs function is to make sure that it doesn't become negative. 13 was added to the next iteration
-- because it helps get the cards from the next cycle, to get a different suit, also to cover more range.
initialGuess :: Int -> ([Card],GameState)
initialGuess n = 
    let increment = 13 `div` n
        newGuess = getGuess increment increment n
    in 
        (newGuess, combinationsOf n [minBound..maxBound])
    where 
        getGuess :: Int -> Int -> Int -> [Card]
        getGuess acc increment counter 
            | counter == 0 = []
            | otherwise = (toEnum (abs (acc - 2)) :: Card) : getGuess (acc + 13 + increment) increment (counter - 1)

-- This function takes in the target and guess set of cards, and return 5 ints corresponding
-- to each of the different feedbacks.
feedback :: [Card] -> [Card] -> (Int,Int,Int,Int,Int)
feedback target guess = (correctCards, lowerRanks, correctRanks, higherRanks, correctSuits)
    where 
        correctCards = length (intersect target guess)
        lowerRanks = length (filter (\c -> rank c < minimum (map rank guess)) target)
        correctRanks = correctR (sortByRank (target)) (sortByRank (guess))
        higherRanks = length (filter (\c -> rank c > maximum (map rank guess)) target)
        correctSuits = correctS (sortBySuit (target)) (sortBySuit (guess)) 
              
-- this function takes in the previous set of Cards predicted prevGuess, the current GameState, and
-- the feedback given back, and returns a set of Cards as the newGuess, as well as a new GameState that
-- has gone through filtering based on the feedback. The GameState will be going through 5 checks based
-- on each of the feedback, and then the prevGuess will be eliminated from GameState too. After that,
-- the function attempts to guess the next guess using tryAdjustCard, if tryAdjustCard does not result in a new
-- guess, it would just take the first set of Cards in the remaining GameState.
nextGuess :: ([Card],GameState) -> (Int,Int,Int,Int,Int) -> ([Card],GameState)
nextGuess (prevGuess, gameState) (correctCards, lowerRanks, correctRanks, higherRanks, correctSuits) = 
    let a1 = checkCorrectCards (prevGuess, gameState) correctCards
        a2 = checkLowerRanks (a1) lowerRanks
        a3 = checkCorrectRanks (a2) correctRanks
        a4 = checkHigherRanks (a3) higherRanks
        a5 = checkCorrectSuits (a4) correctSuits
        (newGuess, newGameState) = a5
        updatedGameState = removeCard (newGuess, newGameState)
        firstCard = selectFirst newGuess updatedGameState
        adjustedCard = tryAdjustCard (newGuess, updatedGameState)
        nextGuess = 
            if adjustedCard == newGuess 
            then firstCard
            else adjustedCard
    in (nextGuess, updatedGameState)

--------------------------------------------------------------------------------------
-- Helper functions for generating GameState        
-- this function takes in an int k, and a list containing all 52 cards, and generate combinations of all
-- those cards of size int k, returning them as GameState.
combinationsOf :: Int -> [Card] -> GameState
combinationsOf k as@(x:xs) | k == 1    = map pure as
                           | k == l    = pure as
                           | k >  l    = []
                           | otherwise = run (l-1) (k-1) as $ combinationsOf (k-1) xs
                             where
                             l = length as

                             run :: Int -> Int -> [a] -> [[a]] -> [[a]]
                             run n k ys cs | n == k    = map (ys ++) cs
                                           | otherwise = map (q:) cs ++ run (n-1) k qs (drop dc cs)
                                           where
                                           (q:qs) = take (n-k+1) ys
                                           dc     = product [(n-k+1)..(n-1)] `div` product [1..(k-1)]
    
--------------------------------------------------------------------------------------
-- Helper functions for feedback
-- Takes two lists of Cards (target and guess), return number of Cards that have the same rank
correctR :: [Card] -> [Card] -> Int
correctR [] _ = 0
correctR (x:xs) ys
    | rank x `elem` (map rank ys) = 1 + correctR xs (deleteFirstByRank (rank x) ys)
    | otherwise = correctR xs ys
    where
        deleteFirstByRank _  [] = []
        deleteFirstByRank target (y:ys) 
            | target == rank y =  ys
            | otherwise = y: deleteFirstByRank  target  ys

-- Takes two lists of Cards (target and guess), return number of Cards that have the same suit
correctS :: [Card] -> [Card] -> Int
correctS [] _ = 0
correctS (x:xs) ys
    | suit x `elem` (map suit ys) = 1 + correctS xs (deleteFirstBySuit (suit x) ys)
    | otherwise = correctS xs ys
    where
        deleteFirstBySuit _  [] = []
        deleteFirstBySuit target (y:ys) 
            | target == suit y = ys
            | otherwise = y: deleteFirstBySuit target  ys
            
--------------------------------------------------------------------------------------
-- Helper functions for nextGuess
-- All the check function takes in a set of Cards, the current GameState, and the feedback
-- number. They then return the same tuple but this time with a new GameState that
-- has filtered off combinations based on the feedback.

-- If all Cards are correct, eliminate all other card combinations
-- If none are correct, eliminate combinations consisting of any of the current Cards
checkCorrectCards :: ([Card], GameState) -> Int -> ([Card], GameState)
checkCorrectCards (prevGuess, gameState) correctCards
    | correctCards == length prevGuess = 
        let newGameState = filter (containsBothCards prevGuess) gameState
        in (prevGuess, newGameState)
    | correctCards == 0 = 
        let newGameState = filter (not . containsAnyCard prevGuess) gameState
        in (prevGuess, newGameState)
    | otherwise = (prevGuess, gameState)
    where 
        containsAnyCard :: [Card] -> [Card] -> Bool
        containsAnyCard prevGuess gameStateLists = any (`elem` gameStateLists) prevGuess
        
        containsBothCards :: [Card] -> [Card] -> Bool
        containsBothCards prevGuess gameStateLists = all (`elem` gameStateLists) prevGuess

-- If all Cards in target are lower than lowest in guess, eliminate all combinations consisting of Cards higher than the lowest in guess
-- If there are no Cards in target lower than the lowest in guess, eliminate all combinations consisting of Cards lower than the lowest in guess
checkLowerRanks :: ([Card], GameState) -> Int -> ([Card], GameState)
checkLowerRanks (prevGuess, gameState) lowerRanks
    | lowerRanks == length (prevGuess) = (prevGuess, filter (containsLowerRanks prevGuess) gameState)
    | lowerRanks == 0 = (prevGuess, filter (containsHigherRanks prevGuess) gameState)
    | otherwise = (prevGuess, gameState)
    where
        containsLowerRanks :: [Card] -> [Card] -> Bool
        containsLowerRanks prevGuess gameStateLists = all (\c -> rank c < minimum (map rank prevGuess)) gameStateLists
        
        containsHigherRanks :: [Card] -> [Card] -> Bool
        containsHigherRanks prevGuess gameStateLists = all (\c -> rank c >= minimum (map rank prevGuess)) gameStateLists
        
-- If all Cards in target have same ranks as Cards in guess, eliminate all other combinations of ranks
-- If there are no Cards in target that have the same ranks as Cards in guess, eliminate all combinations consisting of current ranks
-- If there are some Cards in target that have the same ranks as Cards in guess, eliminate all combinations with ranks exactly 
-- like the current rank, also check and see if the current guess are all of the same rank, if they are, remove all combinations
-- that consist of only the same rank
checkCorrectRanks :: ([Card], GameState) -> Int -> ([Card], GameState)
checkCorrectRanks (prevGuess, gameState) correctRanks
    | correctRanks == length (prevGuess) = 
        let newGameState = filter (containsExactRanks prevGuess) gameState
        in (prevGuess, newGameState)
    | correctRanks == 0 = 
        let newGameState = filter (not . containsAnyRanks prevGuess) gameState
        in (prevGuess, newGameState)
    | otherwise = 
        let newGameState = dropDupRanks prevGuess gameState
            newGuess = prevGuess
        in (newGuess, newGameState)
    where
        containsAllRanks :: [Card] -> [Card] -> Bool
        containsAllRanks prevGuess gameStateLists = all (\c -> rank c `elem` map rank prevGuess) gameStateLists
        
        containsAnyRanks :: [Card] -> [Card] -> Bool
        containsAnyRanks prevGuess gameStateLists = any (\c -> rank c `elem` map rank prevGuess) gameStateLists
        
        containsExactRanks :: [Card] -> [Card] -> Bool
        containsExactRanks prevGuess gameStateLists = sort (map rank prevGuess) == sort (map rank gameStateLists)
        
        dropDupRanks :: [Card] -> GameState -> GameState
        dropDupRanks prevGuess gameState 
            | ifAllSame prevGuess = filter (\x -> not (isDup x) && not (containsExactRanks prevGuess x)) gameState
            | otherwise =  filter (not . containsExactRanks prevGuess) gameState
  
        ifAllSame :: [Card] -> Bool
        ifAllSame prevGuess = length (filter (\c -> rank c == minimum (map rank prevGuess)) prevGuess) == length prevGuess
        
        isDup :: [Card] -> Bool
        isDup [] = False
        isDup (x:xs) = all (\c -> rank c == rank x) xs

-- If all Cards in target are higher than highest in guess, eliminate all combinations consisting of Cards lower than the highest in guess
-- If there are no Cards in target higher than the highest in guess, eliminate all combinations consisting of Cards higher than the highest in guess
checkHigherRanks :: ([Card], GameState) -> Int -> ([Card], GameState)
checkHigherRanks (prevGuess, gameState) higherRanks
    | higherRanks  == length (prevGuess) = (prevGuess, filter (containsHigherRanks prevGuess) gameState)
    | higherRanks == 0 = (prevGuess, filter (containsLowerRanks prevGuess) gameState)
    | otherwise = (prevGuess, gameState)
    where
        containsLowerRanks :: [Card] -> [Card] -> Bool
        containsLowerRanks prevGuess gameStateLists = all (\c -> rank c <= maximum (map rank prevGuess)) gameStateLists
        
        containsHigherRanks :: [Card] -> [Card] -> Bool
        containsHigherRanks prevGuess gameStateLists = all (\c -> rank c > maximum (map rank prevGuess)) gameStateLists

-- If all Cards in target have same suits as Cards in guess, eliminate all other combinations of suits
-- If there are no Cards in target that have the same suits as Cards in guess, eliminate all combinations consisting of current suits
-- If there are some Cards in target that have the same suits as Cards in guess, eliminate all combinations with suits exactly 
-- like the current suit, also check and see if the current guess are all of the same suit, if they are, remove all combinations
-- that consist of only the same suit
checkCorrectSuits :: ([Card], GameState) -> Int -> ([Card], GameState)
checkCorrectSuits (prevGuess, gameState) correctSuits
    | correctSuits == 0 = 
        let newGameState = filter (not . containsAnySuits prevGuess) gameState
        in (prevGuess, newGameState)
    | correctSuits == length (prevGuess) = 
        let newGameState = filter (containsExactSuits prevGuess) gameState
        in (prevGuess, newGameState)
    | otherwise = 
        let newGameState = dropDupSuits prevGuess gameState
            newGuess = prevGuess
        in (newGuess, newGameState)
    where
        containsExactSuits :: [Card] -> [Card] -> Bool
        containsExactSuits prevGuess gameStateLists = sort (map suit prevGuess) == sort (map suit gameStateLists)
        
        containsAnySuits :: [Card] -> [Card] -> Bool
        containsAnySuits prevGuess gameStateLists = any (\c -> suit c `elem` map suit prevGuess) gameStateLists
        
        dropDupSuits :: [Card] -> GameState -> GameState
        dropDupSuits prevGuess gameState 
            | ifAllSame = filter (\x -> not (isDup x) && not (containsExactSuits prevGuess x)) gameState
            | otherwise =  filter (not . containsExactSuits prevGuess) gameState
            where 
                ifAllSame = length (filter (\c -> suit c == minimum (map suit prevGuess)) prevGuess) == length prevGuess
                isDup (x:xs) = all (\c -> suit c == suit x) xs

-- Takes in the current guess and GameState and attempts to return the next guess by shifting the Card 
-- with the smallest or biggest rank. If no new Cards are found, just return prevGuess, which would be handled later
tryAdjustCard :: ([Card], GameState) -> [Card]
tryAdjustCard (prevGuess, gameState) = 
    let newGuess = tryGuessLowerGroups (prevGuess, gameState)
    in if newGuess == prevGuess
        then tryGuessUpperGroups (prevGuess, gameState)
        else if newGuess == []
             then prevGuess
             else newGuess

-- Takes in the current guess and GameState and attempts to make a guess by returning a Card set
-- that has Cards either bigger or lower than the minimum of current guess
tryGuessLowerGroups :: ([Card], GameState) -> [Card]
tryGuessLowerGroups (prevGuess, gameState) = 
    let newGuess = tryGuessLower "up" (prevGuess, gameState)
    in if newGuess == prevGuess
        then tryGuessLower "down" (prevGuess, gameState)
        else newGuess
   
-- Takes in the current guess and GameState and attempts to make a guess by returning a Card set
-- that has Cards either bigger or lower than the maximum of current guess
tryGuessUpperGroups :: ([Card], GameState) -> [Card]
tryGuessUpperGroups (prevGuess, gameState) = 
    let newGuess = tryGuessHigher "up" (prevGuess, gameState)
    in if newGuess == prevGuess
        then tryGuessHigher "down" (prevGuess, gameState)
        else newGuess
 
-- Takes in a String as its direction as well as the guess and GameState. If the direction
-- is up, return the first Card set that contains ranks bigger than the minimum of current guess.
-- If not, return the first Card set that contains ranks smaller than the minimum of current guess.
tryGuessLower :: String -> ([Card], GameState) -> [Card]
tryGuessLower direction (prevGuess, gameState) = 
    if direction == "up"
    then 
        let biggerLists = filter (containsHigherRanks prevGuess) gameState
            firstCardList = selectFirst prevGuess biggerLists
        in firstCardList
    else 
        let smallerLists =  filter (containsLowerRanks prevGuess) gameState
            firstCardList = selectFirst prevGuess smallerLists
        in firstCardList
    where 
        containsHigherRanks :: [Card] -> [Card] -> Bool
        containsHigherRanks prevGuess gameStateLists = all (\c -> rank c > minimum (map rank prevGuess)) gameStateLists
            
        containsLowerRanks :: [Card] -> [Card] -> Bool
        containsLowerRanks prevGuess gameStateLists = all (\c -> rank c < minimum (map rank prevGuess)) gameStateLists

-- Takes in a String as its direction as well as the guess and GameState. If the direction
-- is up, return the first Card set that contains ranks bigger than the maximum of current guess.
-- If not, return the first Card set that contains ranks smaller than the maximum of current guess.
tryGuessHigher :: String -> ([Card], GameState) -> [Card]
tryGuessHigher direction (prevGuess, gameState) = 
    if direction == "up"
    then 
        let biggerLists = filter (containsHigherRanks prevGuess) gameState
            firstCardList = selectFirst prevGuess biggerLists
        in firstCardList
    else 
        let smallerLists =  filter (containsLowerRanks prevGuess) gameState
            firstCardList = selectFirst prevGuess smallerLists
        in firstCardList
    where 
        containsHigherRanks :: [Card] -> [Card] -> Bool
        containsHigherRanks prevGuess gameStateLists = all (\c -> rank c > maximum (map rank prevGuess)) gameStateLists
            
        containsLowerRanks :: [Card] -> [Card] -> Bool
        containsLowerRanks prevGuess gameStateLists = all (\c -> rank c < maximum (map rank prevGuess)) gameStateLists

-- Sort a list of Cards by their ranks
sortByRank :: [Card] -> [Card]
sortByRank = sortBy (\c1 c2 -> compare (rank c1) (rank c2))

-- Sort a list of Cards by their suits
sortBySuit :: [Card] -> [Card]
sortBySuit = sortBy (\c1 c2 -> compare (suit c1) (suit c2))

-- Select the first combination in GameState
selectFirst :: [Card] -> GameState -> [Card]
selectFirst prevGuess [] = prevGuess
selectFirst prevGuess (x:_) = x

-- This function takes in a set of Cards and the current GameState, and removes that set of Cards 
-- from the current GameState
removeCard :: ([Card], GameState) -> GameState
removeCard (_,[]) = []
removeCard (target, (x:xs))
    | target == x = removeCard (target, xs)
    | otherwise = x : removeCard (target, xs)



